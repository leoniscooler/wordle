<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Leon’s Wordle</title>
  <style>
    :root{
      --bg:#0b1220; --tile:#111827; --text:#e6eef8; --muted:#9aa7bf;
      --green:#6aaa64; --yellow:#c9b458; --gray:#3a3a3c; --accent:#2563eb;
      --tile-size:64px;
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
    }
    *{box-sizing:border-box}
    body{margin:0; background:linear-gradient(180deg,#071020,#0b1220); color:var(--text);
      display:flex; align-items:center; justify-content:center; min-height:100vh; padding:20px;}
    .app{ width: min(760px, 96vw); text-align:center; }
    h1{margin:0 0 6px 0; font-size:22px}
    p.lead{color:var(--muted); margin:4px 0 12px 0}
    .board{display:grid; grid-template-rows: repeat(6, var(--tile-size)); gap:8px; justify-content:center; margin:18px 0;}
    .row{ display:grid; grid-template-columns: repeat(5, var(--tile-size)); gap:8px; }
    .tile{ width:var(--tile-size); height:var(--tile-size); background:var(--tile);
      display:flex; align-items:center; justify-content:center; font-weight:700; font-size:28px;
      border-radius:8px; user-select:none; color:var(--text); text-transform:uppercase;
      transition: transform .08s ease, background .2s ease; }
    .tile.pop{ transform: scale(1.08); }
    .tile.filled{ border:2px solid #2b3440; }
    .tile.absent{ background:var(--gray); color:white; }
    .tile.present{ background:var(--yellow); color:white; }
    .tile.correct{ background:var(--green); color:white; }
    .keyboard{ margin-top:10px; display:flex; flex-direction:column; gap:8px; align-items:center; user-select:none; }
    .kb-row{ display:flex; gap:6px; }
    .key{ padding:10px 12px; min-width:42px; border-radius:6px; background:#0f1724; color:var(--text);
      font-weight:700; cursor:pointer; text-transform:uppercase; transition: background .3s ease; text-align:center; }
    .key.wide{ min-width:72px; }
    .key.absent{ background: var(--gray); color: white; }
    .key.present{ background: var(--yellow); color: white; }
    .key.correct{ background: var(--green); color: white; }
    .status{ margin-top:14px; min-height:28px; color:var(--muted); font-weight:700; }
    .controls{ margin-top:12px; display:flex; gap:8px; justify-content:center; flex-wrap:wrap; }
    button.btn{ background:var(--accent); color:white; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:700; }
    .small{ font-size:13px; color:var(--muted); margin-top:6px;}
    /* Stats popup */
    #statsPopup{ display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
      background:#0f1724; padding:18px; border-radius:10px; box-shadow:0 20px 40px rgba(0,0,0,0.6); z-index:1000; color:var(--text); width:320px; max-width:92vw; }
    #statsPopup h2{ margin:0 0 8px 0; font-size:18px; }
    .stat-row{ display:flex; justify-content:space-between; margin:6px 0; color:var(--muted); }
    .dist-bar{ height:20px; background:#111827; border-radius:6px; overflow:hidden; display:flex; align-items:center; }
    .dist-fill{ height:100%; background:var(--accent); min-width:4px; display:block; }
    .dist-label{ width:32px; text-align:left; padding-right:8px; font-weight:700; color:var(--text); }
    .popup-actions{ display:flex; gap:8px; justify-content:flex-end; margin-top:12px; }
    /* overlay */
    #overlay{ display:none; position:fixed; inset:0; background:rgba(0,0,0,0.45); z-index:900; }
    @media (max-width:520px){ :root{ --tile-size:48px } .key{ padding:8px 10px } .controls{justify-content:center} #statsPopup{ width:92vw } }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Leon’s Wordle">
    <h1>Leon’s Wordle</h1>
    <p class="lead">Use the "Custom Word" button to create a shareable link for any 5-letter word!</p>

    <div id="board" class="board" aria-live="polite"></div>
    <div id="status" class="status" aria-atomic="true">Loading word lists...</div>
    <div id="keyboard" class="keyboard"></div>

    <div class="controls">
      <button id="newBtn" class="btn">New Game</button>
      <button id="shareBtn" class="btn" title="Copy result to clipboard">Share</button>
      <button id="customBtn" class="btn" title="Create a custom Wordle link">Custom Word</button>
      <button id="statsBtn" class="btn" title="Show statistics">Stats</button>
    </div>
    <p class="small">If fetching the full lists fails (offline), the game will still run with a small fallback list.</p>
  </div>

  <!-- Overlay + Stats Popup -->
  <div id="overlay" onclick="closeStats()"></div>
  <div id="statsPopup" role="dialog" aria-modal="true" aria-labelledby="statsTitle">
    <h2 id="statsTitle">Statistics</h2>
    <div class="stat-row"><div>Games Played</div><div id="statGames">0</div></div>
    <div class="stat-row"><div>Win %</div><div id="statWins">0%</div></div>
    <div class="stat-row"><div>Current Streak</div><div id="statCurrent">0</div></div>
    <div class="stat-row"><div>Best Streak</div><div id="statBest">0</div></div>

    <h3 style="margin-top:12px; margin-bottom:8px; font-size:14px; color:var(--muted)">Guess Distribution</h3>
    <div id="distList" style="display:flex; flex-direction:column; gap:6px;"></div>

    <div class="popup-actions">
      <button id="closeStatsBtn" class="btn">Close</button>
    </div>
  </div>

<script>
/* ========= Game constants and DOM refs ========= */
const ROWS = 6, COLS = 5;
const boardEl = document.getElementById('board');
const keyboardEl = document.getElementById('keyboard');
const statusEl = document.getElementById('status');
const newBtn = document.getElementById('newBtn');
const shareBtn = document.getElementById('shareBtn');
const customBtn = document.getElementById('customBtn');
const statsBtn = document.getElementById('statsBtn');

const overlay = document.getElementById('overlay');
const statsPopup = document.getElementById('statsPopup');
const distList = document.getElementById('distList');
const closeStatsBtn = document.getElementById('closeStatsBtn');

let grid = [];
let curRow = 0, curCol = 0;
let solution = "";
let finished = false;
let keyStates = {};
let SOLUTIONS = [];
let VALID = new Set();

/* Fallback small lists if fetch fails */
const FALLBACK_SOLUTIONS = ["apple","baker","cigar","delta","eagle","flame","grace","hotel","image","jelly"];
const FALLBACK_VALID = new Set([...FALLBACK_SOLUTIONS, "about","other","which","their","there","could","would","these","think","place","under","right","first","still"]);

/* Gist raw URLs */
const GIST_ANSWERS_RAW = "https://gist.githubusercontent.com/cfreshman/a03ef2cba789d8cf00c08f767e0fad7b/raw/wordle-answers-alphabetical.txt";
const GIST_ALLOWED_RAW  = "https://gist.githubusercontent.com/cfreshman/cdcdf777450c5b5301e439061d29694c/raw/wordle-allowed-guesses.txt";

/* ========= Stats handling (localStorage) ========= */
let stats = {
  gamesPlayed: 0,
  gamesWon: 0,
  currentStreak: 0,
  bestStreak: 0,
  guessDist: [0,0,0,0,0,0] // index 0 = win in 1 guess, index 5 = win in 6 guesses
};

function loadStats(){
  try {
    const saved = localStorage.getItem("leon_wordle_stats");
    if(saved){
      const parsed = JSON.parse(saved);
      // Basic validation
      if(parsed && typeof parsed === 'object' && Array.isArray(parsed.guessDist) && parsed.guessDist.length===6){
        stats = parsed;
      }
    }
  } catch(e){
    console.warn("Failed to load stats:", e);
  }
}

function saveStats(){
  try {
    localStorage.setItem("leon_wordle_stats", JSON.stringify(stats));
  } catch(e){
    console.warn("Failed to save stats:", e);
  }
}

function resetStats(){
  stats = {
    gamesPlayed: 0,
    gamesWon: 0,
    currentStreak: 0,
    bestStreak: 0,
    guessDist: [0,0,0,0,0,0]
  };
  saveStats();
  updateStatsUI();
}

/* ========= UI Builders ========= */
function buildBoard(){
  boardEl.innerHTML = "";
  grid = [];
  for(let r=0;r<ROWS;r++){
    const row = document.createElement('div'); row.className='row';
    let rowArr = [];
    for(let c=0;c<COLS;c++){
      const tile = document.createElement('div'); tile.className='tile';
      tile.dataset.row=r; tile.dataset.col=c; tile.setAttribute('role','gridcell');
      row.appendChild(tile); rowArr.push(tile);
    }
    boardEl.appendChild(row); grid.push(rowArr);
  }
}

const KEYBOARD_ROWS = ["qwertyuiop","asdfghjkl","zxcvbnm"];
function buildKeyboard(){
  keyboardEl.innerHTML = "";
  KEYBOARD_ROWS.forEach((row, idx)=>{
    const r = document.createElement('div'); r.className='kb-row';
    if(idx===2){
      const enter = document.createElement('div'); enter.className='key wide'; enter.textContent='Enter';
      enter.dataset.key='Enter'; enter.onclick = ()=>handleKey('Enter'); r.appendChild(enter);
    }
    for(const ch of row){
      const key = document.createElement('div'); key.className='key'; key.textContent=ch; key.dataset.key=ch;
      key.onclick = ()=>handleKey(ch); r.appendChild(key);
    }
    if(idx===2){
      const bk = document.createElement('div'); bk.className='key wide'; bk.textContent='Back'; bk.dataset.key='Backspace';
      bk.onclick = ()=>handleKey('Backspace'); r.appendChild(bk);
    }
    keyboardEl.appendChild(r);
  });
}

function updateKeyboardUI(){
  const keys = keyboardEl.querySelectorAll('.key');
  keys.forEach(k=>{
    const ch = (k.dataset.key || '').toLowerCase();
    k.classList.remove('absent','present','correct');
    if(ch && keyStates[ch]) k.classList.add(keyStates[ch]);
  });
}

/* ========= Word lists loading ========= */
async function loadLists(){
  statusEl.textContent = "Fetching Wordle lists...";
  try{
    const [ansResp, allowedResp] = await Promise.all([
      fetch(GIST_ANSWERS_RAW),
      fetch(GIST_ALLOWED_RAW)
    ]);

    if(!ansResp.ok || !allowedResp.ok) throw new Error("Fetch failed");

    const [ansText, allowedText] = await Promise.all([ansResp.text(), allowedResp.text()]);

    SOLUTIONS = ansText.split(/\r?\n/).map(s=>s.trim().toLowerCase()).filter(s=>s.length===5);
    const allowed = allowedText.split(/\r?\n/).map(s=>s.trim().toLowerCase()).filter(s=>s.length===5);

    VALID = new Set(allowed);
    SOLUTIONS.forEach(w=>VALID.add(w));

    statusEl.textContent = `Loaded ${SOLUTIONS.length} solutions and ${VALID.size} allowed guesses.`;
    console.log("Loaded lists: solutions:", SOLUTIONS.length, "allowed:", VALID.size);
  }catch(err){
    console.warn("Failed to fetch lists, using fallback. Error:", err);
    statusEl.textContent = "Offline or blocked — using fallback small word list.";
    SOLUTIONS = FALLBACK_SOLUTIONS.slice();
    VALID = new Set(FALLBACK_VALID);
  }
}

/* ========= Custom word from hash ========= */
function getCustomWordFromHash(){
  const hash = window.location.hash.slice(1);
  if(!hash.startsWith("custom=")) return null;
  const code = hash.slice(7);
  try {
    const word = atob(code).toLowerCase();
    if(word.length !== 5) return null;
    if(!/^[a-z]{5}$/.test(word)) return null; // Only letters allowed
    return word;
  } catch(e) {
    return null;
  }
}

/* ========= Game flow ========= */
function pickSolution(){
  const custom = getCustomWordFromHash();
  if(custom){
    solution = custom;
    // Do NOT show the solution to user to avoid cheating
    statusEl.textContent = "Good luck — guess the 5-letter word!";
    if(!VALID.has(solution)){
      VALID.add(solution);  // Add custom word to VALID guesses so you can guess it!
    }
  } else {
    if(SOLUTIONS.length === 0){
      solution = FALLBACK_SOLUTIONS[Math.floor(Math.random()*FALLBACK_SOLUTIONS.length)];
    } else {
      solution = SOLUTIONS[Math.floor(Math.random()*SOLUTIONS.length)];
    }
    statusEl.textContent = "Good luck — guess the 5-letter word!";
  }
  console.log("solution:", solution);
}

function startNewGame(){
  buildBoard();
  buildKeyboard();
  curRow = 0; curCol = 0; finished = false; keyStates = {};
  updateKeyboardUI();
  pickSolution();
}

function putLetter(ch){
  if(finished) return;
  if(curCol >= COLS) return;
  grid[curRow][curCol].textContent = ch.toUpperCase();
  grid[curRow][curCol].classList.add('filled');
  curCol++;
}

function popLetter(){
  if(finished) return;
  if(curCol <= 0) return;
  curCol--;
  grid[curRow][curCol].textContent = "";
  grid[curRow][curCol].classList.remove('filled');
}

function getGuess(){
  let s="";
  for(let c=0;c<COLS;c++) s += (grid[curRow][c].textContent || "").toLowerCase();
  return s;
}

/* Reveal and mark tiles. This handles repeated letters correctly. */
function revealGuess(guess){
  const solArr = solution.split('');
  const state = Array(COLS).fill('absent');

  // First pass: correct
  for(let i=0;i<COLS;i++){
    if(guess[i] === solArr[i]){
      state[i] = 'correct';
      solArr[i] = null;
    }
  }

  // Count remaining letters in solution
  const counts = {};
  for(const ch of solArr){
    if(!ch) continue;
    counts[ch] = (counts[ch]||0)+1;
  }

  // Second pass: present or absent
  for(let i=0;i<COLS;i++){
    if(state[i] === 'correct') continue;
    const g = guess[i];
    if(counts[g] > 0){
      state[i] = 'present';
      counts[g]--;
    } else {
      state[i] = 'absent';
    }
  }

  // Animate and update keyboard states
  for(let i=0;i<COLS;i++){
    const tile = grid[curRow][i];
    ((tile, cls, ch, idx)=>{
      setTimeout(()=>{
        tile.classList.add('pop');
        tile.classList.add(cls);

        const prev = keyStates[ch] || '';
        if(prev === 'correct'){
          // keep correct
        } else if(prev === 'present'){
          if(cls === 'correct') keyStates[ch] = 'correct';
        } else {
          keyStates[ch] = cls;
        }
        updateKeyboardUI();
      }, idx*240);
      setTimeout(()=> tile.classList.remove('pop'), idx*240 + 420);
    })(tile, state[i], guess[i], i);
  }
  return state;
}

/* ========= Handle keys and game end (update stats here) ========= */
function showMessage(msg, timeout=2200){
  statusEl.textContent = msg;
  if(timeout>0) setTimeout(()=>{ if(statusEl.textContent===msg) statusEl.textContent = ""; }, timeout);
}

function handleKey(key){
  if(finished) return;
  if(key === 'Enter'){
    if(curCol < COLS){ showMessage("Not enough letters"); return; }
    const guess = getGuess();
    if(!VALID.has(guess)){
      showMessage("Not in word list");
      return;
    }
    const state = revealGuess(guess);
    curRow++;
    curCol = 0;

    if(guess === solution){
      finished = true;
      stats.gamesPlayed++;
      stats.gamesWon++;
      stats.currentStreak++;
      if(stats.currentStreak > stats.bestStreak) stats.bestStreak = stats.currentStreak;
      stats.guessDist[curRow-1]++;
      saveStats();
      showMessage(`You won in ${curRow} guess${curRow>1?'es':''}!`, 6000);
      return;
    }

    if(curRow >= ROWS){
      finished = true;
      stats.gamesPlayed++;
      stats.currentStreak = 0;
      saveStats();
      showMessage(`Game over! Word was ${solution.toUpperCase()}`, 6000);
      return;
    }
    showMessage("Good guess!");
  } else if(key === 'Backspace'){
    popLetter();
  } else if(key.length === 1 && /^[a-z]$/i.test(key)){
    putLetter(key.toLowerCase());
  }
}

/* ========= Share and custom word logic ========= */
function shareResults(){
  if(!finished){
    showMessage("Finish the game first!");
    return;
  }
  let text = `Leon’s Wordle\n`;
  text += `Word: ${solution.toUpperCase()}\n`;
  text += `Guesses: ${curRow}\n\n`;
  text += "Results:\n";
  for(let r=0; r<curRow; r++){
    for(let c=0; c<COLS; c++){
      const tile = grid[r][c];
      if(tile.classList.contains('correct')) text += "🟩";
      else if(tile.classList.contains('present')) text += "🟨";
      else text += "⬛";
    }
    text += "\n";
  }
  navigator.clipboard.writeText(text).then(() => {
    showMessage("Copied results to clipboard!", 3000);
  }).catch(() => {
    showMessage("Failed to copy.");
  });
}

function promptCustomWord(){
  let w = prompt("Enter a 5-letter word (letters only):");
  if(!w) return;
  w = w.toLowerCase().trim();
  if(w.length !== 5 || !/^[a-z]{5}$/.test(w)){
    alert("Invalid word. Must be 5 letters and only a-z.");
    return;
  }
  // Create custom link
  const code = btoa(w);
  const url = `${window.location.origin}${window.location.pathname}#custom=${code}`;
  prompt("Share this link to play your custom word:", url);
}

/* ========= Stats UI ========= */
function updateStatsUI(){
  document.getElementById('statGames').textContent = stats.gamesPlayed;
  document.getElementById('statWins').textContent = (stats.gamesPlayed===0)? "0%" : Math.round(stats.gamesWon*100/stats.gamesPlayed)+"%";
  document.getElementById('statCurrent').textContent = stats.currentStreak;
  document.getElementById('statBest').textContent = stats.bestStreak;

  distList.innerHTML = "";
  const max = Math.max(...stats.guessDist, 1);
  stats.guessDist.forEach((count,i)=>{
    const row = document.createElement('div'); row.style.display = 'flex'; row.style.alignItems = 'center'; row.style.gap = '6px';

    const label = document.createElement('div'); label.className='dist-label'; label.textContent = (i+1);
    const barBg = document.createElement('div'); barBg.className = 'dist-bar'; barBg.style.flex = '1';

    const barFill = document.createElement('div'); barFill.className = 'dist-fill';
    const widthPercent = (count/max)*100;
    barFill.style.width = widthPercent + '%';
    barFill.textContent = count > 0 ? count : '';

    barBg.appendChild(barFill);
    row.appendChild(label);
    row.appendChild(barBg);
    distList.appendChild(row);
  });
}

function showStats(){
  updateStatsUI();
  overlay.style.display = 'block';
  statsPopup.style.display = 'block';
}

function closeStats(){
  overlay.style.display = 'none';
  statsPopup.style.display = 'none';
}

/* ========= Event Listeners ========= */
window.addEventListener('keydown', e=>{
  if(e.ctrlKey || e.metaKey || e.altKey) return;
  if(finished && e.key !== 'Enter') return;
  handleKey(e.key);
});

newBtn.onclick = startNewGame;
shareBtn.onclick = shareResults;
customBtn.onclick = promptCustomWord;
statsBtn.onclick = showStats;
closeStatsBtn.onclick = closeStats;
overlay.onclick = closeStats;

/* ========= Initialize ========= */
loadStats();
loadLists().then(() => {
  startNewGame();
});

</script>
</body>
</html>
