<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Leon’s Wordle</title>
  <style>
    :root{
      --bg:#0b1220; --tile:#111827; --text:#e6eef8; --muted:#9aa7bf;
      --green:#6aaa64; --yellow:#c9b458; --gray:#3a3a3c; --accent:#2563eb;
      --tile-size:64px;
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    }
    *{box-sizing:border-box}
    body{margin:0; background:linear-gradient(180deg,#071020,#0b1220); color:var(--text);
      display:flex; align-items:center; justify-content:center; min-height:100vh; padding:20px;}
    .app{ width: min(760px, 96vw); text-align:center; position: relative;}
    h1{margin:0 0 6px 0; font-size:22px; display: flex; justify-content: center; align-items: center; gap: 12px;}
    .timer {
      font-size: 14px;
      font-weight: 700;
      color: var(--muted);
      font-family: monospace;
      user-select: none;
      min-width: 56px;
      text-align: right;
    }
    p.lead{color:var(--muted); margin:4px 0 12px 0}
    .board{display:grid; grid-template-rows: repeat(6, var(--tile-size)); gap:8px; justify-content:center; margin:18px 0;}
    .row{ display:grid; grid-template-columns: repeat(5, var(--tile-size)); gap:8px; }
    .tile{ width:var(--tile-size); height:var(--tile-size); background:var(--tile);
      display:flex; align-items:center; justify-content:center; font-weight:700; font-size:28px;
      border-radius:8px; user-select:none; color:var(--text); text-transform:uppercase;
      transition: transform .08s ease, background .2s ease; }
    .tile.pop{ transform: scale(1.08); }
    .tile.filled{ border:2px solid #2b3440; }
    .tile.absent{ background:var(--gray); color:white; }
    .tile.present{ background:var(--yellow); color:white; }
    .tile.correct{ background:var(--green); color:white; }
    .keyboard{ margin-top:10px; display:flex; flex-direction:column; gap:8px; align-items:center; user-select:none; }
    .kb-row{ display:flex; gap:6px; }
    .key{ padding:10px 12px; min-width:42px; border-radius:6px; background:#0f1724; color:var(--text);
      font-weight:700; cursor:pointer; text-transform:uppercase; transition: background .3s ease; }
    .key.wide{ min-width:72px; }
    .key.absent{ background: var(--gray); color: white; }
    .key.present{ background: var(--yellow); color: white; }
    .key.correct{ background: var(--green); color: white; }
    .status{ margin-top:14px; min-height:28px; color:var(--muted); font-weight:700; }
    .controls{ margin-top:12px; display:flex; gap:8px; justify-content:center; flex-wrap:wrap; }
    button.btn{ background:var(--accent); color:white; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:700; }
    .small{ font-size:13px; color:var(--muted); margin-top:6px;}
    /* Stats modal styles */
    #statsModal {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: var(--tile); color: var(--text);
      border-radius: 12px; padding: 20px; width: 320px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.6);
      display: none; flex-direction: column; max-height: 90vh;
      overflow-y: auto;
      z-index: 1000;
    }
    #statsModal.active { display: flex; }
    #statsModal h2 { margin-top: 0; text-align: center; }
    #statsModal .close-btn {
      align-self: flex-end;
      background: transparent; border: none; color: var(--muted);
      font-size: 20px; cursor: pointer; font-weight: 700;
      margin-bottom: 12px;
    }
    .stat-row { display: flex; justify-content: space-between; margin: 6px 0; }
    .dist-bar-row { display: flex; align-items: center; margin: 6px 0; }
    .dist-label {
      width: 20px; font-weight: 700; user-select: none; color: var(--muted);
    }
    .dist-bar {
      flex-grow: 1; height: 16px; background: var(--gray); border-radius: 6px; margin-left: 8px; overflow: hidden;
      position: relative;
    }
    .dist-bar-fill {
      height: 100%; background: var(--green); color: #fff; text-align: right; font-size: 12px; font-weight: 700;
      padding-right: 4px; line-height: 16px; border-radius: 6px 0 0 6px;
      white-space: nowrap; user-select: none;
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Leon’s Wordle">
    <h1>
      Leon’s Wordle
      <span class="timer" id="timer">00:00</span>
    </h1>
    <p class="lead">Use the "Custom Word" button to create a shareable link for any 5-letter word!</p>

    <div id="board" class="board" aria-live="polite"></div>
    <div id="status" class="status" aria-atomic="true">Loading word lists...</div>
    <div id="keyboard" class="keyboard"></div>

    <div class="controls">
      <button id="newBtn" class="btn">New Game</button>
      <button id="shareBtn" class="btn" title="Copy result to clipboard">Share</button>
      <button id="customBtn" class="btn" title="Create a custom Wordle link">Custom Word</button>
      <button id="statsBtn" class="btn" title="Show statistics">Stats</button>
    </div>
    <p class="small">If fetching the full lists fails (offline), the game will still run with a small fallback list.</p>
  </div>

  <div id="statsModal" role="dialog" aria-modal="true" aria-labelledby="statsTitle" tabindex="-1">
    <button class="close-btn" id="closeStatsBtn" aria-label="Close statistics popup">×</button>
    <h2 id="statsTitle">Statistics</h2>
    <div class="stat-row"><div>Games Played:</div><div id="statPlayed">0</div></div>
    <div class="stat-row"><div>Wins:</div><div id="statWins">0</div></div>
    <div class="stat-row"><div>Losses:</div><div id="statLosses">0</div></div>
    <div class="stat-row"><div>Win %:</div><div id="statWinPercent">0%</div></div>
    <div class="stat-row"><div>Loss %:</div><div id="statLossPercent">0%</div></div>
    <div class="stat-row"><div>Last Solve Time:</div><div id="statLastTime">-</div></div>
    <div class="stat-row"><div>Best Solve Time:</div><div id="statBestTime">-</div></div>
    <div class="stat-row"><div>Average Solve Time:</div><div id="statAvgTime">-</div></div>
    <div style="margin-top:12px; font-weight:700; text-align:center;">Guess Distribution</div>
    <div id="distBars"></div>
    <div style="margin-top:12px; font-weight:700; text-align:center;" id="favWord">Favorite Word: -</div>
  </div>

<script>
const ROWS = 6, COLS = 5;
const boardEl = document.getElementById('board');
const keyboardEl = document.getElementById('keyboard');
const statusEl = document.getElementById('status');
const newBtn = document.getElementById('newBtn');
const shareBtn = document.getElementById('shareBtn');
const customBtn = document.getElementById('customBtn');
const statsBtn = document.getElementById('statsBtn');
const statsModal = document.getElementById('statsModal');
const closeStatsBtn = document.getElementById('closeStatsBtn');

const statPlayedEl = document.getElementById('statPlayed');
const statWinsEl = document.getElementById('statWins');
const statLossesEl = document.getElementById('statLosses');
const statWinPercentEl = document.getElementById('statWinPercent');
const statLossPercentEl = document.getElementById('statLossPercent');
const statLastTime = document.getElementById('statLastTime');
const statBestTime = document.getElementById('statBestTime');
const statAvgTime = document.getElementById('statAvgTime');
const distBarsEl = document.getElementById('distBars');
const favWordEl = document.getElementById('favWord');

let grid = [];
let curRow = 0, curCol = 0;
let solution = "";
let finished = false;
let keyStates = {};
let SOLUTIONS = [];
let VALID = new Set();

const FALLBACK_SOLUTIONS = ["apple","baker","cigar","delta","eagle","flame","grace","hotel","image","jelly"];
const FALLBACK_VALID = new Set([...FALLBACK_SOLUTIONS, "about","other","which","their","there","could","would","these","think","place","under","right","first","still"]);

const GIST_ANSWERS_RAW = "https://gist.githubusercontent.com/cfreshman/a03ef2cba789d8cf00c08f767e0fad7b/raw/wordle-answers-alphabetical.txt";
const GIST_ALLOWED_RAW  = "https://gist.githubusercontent.com/cfreshman/cdcdf777450c5b5301e439061d29694c/raw/wordle-allowed-guesses.txt";

// Statistics data
let stats = {
  gamesPlayed: 0,
  gamesWon: 0,
  gamesLost: 0,
  guessDist: [0,0,0,0,0,0],
  guessesMade: {}, // word -> count
  lastSolveTime: null,
  bestSolveTime: null,
  solveTimes: []
};

let startTime = null;
let timerInterval = null;
const timerEl = document.getElementById('timer');

function buildBoard(){
  boardEl.innerHTML = "";
  grid = [];
  for(let r=0;r<ROWS;r++){
    const row = document.createElement('div'); row.className='row';
    let rowArr = [];
    for(let c=0;c<COLS;c++){
      const tile = document.createElement('div'); tile.className='tile';
      tile.dataset.row=r; tile.dataset.col=c; tile.setAttribute('role','gridcell');
      row.appendChild(tile); rowArr.push(tile);
    }
    boardEl.appendChild(row); grid.push(rowArr);
  }
}

const KEYBOARD_ROWS = ["qwertyuiop","asdfghjkl","zxcvbnm"];
function buildKeyboard(){
  keyboardEl.innerHTML = "";
  KEYBOARD_ROWS.forEach((row, idx)=>{
    const r = document.createElement('div'); r.className='kb-row';
    if(idx===2){
      const enter = document.createElement('div'); enter.className='key wide'; enter.textContent='Enter';
      enter.dataset.key='Enter'; enter.onclick = ()=>handleKey('Enter'); r.appendChild(enter);
    }
    for(const ch of row){
      const key = document.createElement('div'); key.className='key'; key.textContent=ch; key.dataset.key=ch;
      key.onclick = ()=>handleKey(ch); r.appendChild(key);
    }
    if(idx===2){
      const bk = document.createElement('div'); bk.className='key wide'; bk.textContent='Back'; bk.dataset.key='Backspace';
      bk.onclick = ()=>handleKey('Backspace'); r.appendChild(bk);
    }
    keyboardEl.appendChild(r);
  });
}

async function loadLists(){
  statusEl.textContent = "Fetching Wordle lists...";
  try{
    const [ansResp, allowedResp] = await Promise.all([
      fetch(GIST_ANSWERS_RAW),
      fetch(GIST_ALLOWED_RAW)
    ]);

    if(!ansResp.ok || !allowedResp.ok) throw new Error("Fetch failed");

    const [ansText, allowedText] = await Promise.all([ansResp.text(), allowedResp.text()]);

    SOLUTIONS = ansText.split(/\r?\n/).map(s=>s.trim().toLowerCase()).filter(s=>s.length===5);
    const allowed = allowedText.split(/\r?\n/).map(s=>s.trim().toLowerCase()).filter(s=>s.length===5);

    VALID = new Set(allowed);
    SOLUTIONS.forEach(w=>VALID.add(w));

    statusEl.textContent = `Loaded ${SOLUTIONS.length} solutions and ${VALID.size} allowed guesses.`;
    console.log("Loaded lists: solutions:", SOLUTIONS.length, "allowed:", VALID.size);
  }catch(err){
    console.warn("Failed to fetch lists, using fallback. Error:", err);
    statusEl.textContent = "Offline or blocked — using fallback small word list.";
    SOLUTIONS = FALLBACK_SOLUTIONS.slice();
    VALID = new Set(FALLBACK_VALID);
  }
}

function getCustomWordFromHash(){
  const hash = window.location.hash.slice(1);
  if(!hash.startsWith("custom=")) return null;
  const code = hash.slice(7);
  try {
    const word = atob(code).toLowerCase();
    if(word.length !== 5) return null;
    if(!/^[a-z]{5}$/.test(word)) return null; // Only letters allowed
    return word;
  } catch(e) {
    return null;
  }
}

function pickSolution(){
  const custom = getCustomWordFromHash();
  if(custom){
    solution = custom;
    if(!VALID.has(solution)){
      VALID.add(solution);  // Add custom word to VALID guesses so you can guess it!
      // Do NOT show any message about the custom word to prevent cheating
    }
  } else {
    solution = SOLUTIONS[Math.floor(Math.random()*SOLUTIONS.length)];
    statusEl.textContent = "Good luck — guess the 5-letter word!";
  }
  console.log("solution:", solution);
}

function startNewGame(){
  buildBoard();
  buildKeyboard();
  curRow = 0; curCol = 0; finished = false; keyStates = {};
  updateKeyboardUI();
  pickSolution();
  resetTimer();
  updateStatsDisplay();
}

function putLetter(ch){
  if(finished) return;
  if(curCol >= COLS) return;
  grid[curRow][curCol].textContent = ch.toUpperCase();
  grid[curRow][curCol].classList.add('filled');
  curCol++;
}

function popLetter(){
  if(finished) return;
  if(curCol <= 0) return;
  curCol--;
  grid[curRow][curCol].textContent = "";
  grid[curRow][curCol].classList.remove('filled');
}

function getGuess(){
  let s="";
  for(let c=0;c<COLS;c++) s += (grid[curRow][c].textContent || "").toLowerCase();
  return s;
}

function revealGuess(guess){
  const solArr = solution.split('');
  const state = Array(COLS).fill('absent');

  for(let i=0;i<COLS;i++){
    if(guess[i] === solArr[i]){
      state[i] = 'correct';
      solArr[i] = null;
    }
  }

  const counts = {};
  for(const ch of solArr){
    if(!ch) continue;
    counts[ch] = (counts[ch]||0)+1;
  }

  for(let i=0;i<COLS;i++){
    if(state[i] === 'correct') continue;
    const g = guess[i];
    if(counts[g] > 0){
      state[i] = 'present';
      counts[g]--;
    } else {
      state[i] = 'absent';
    }
  }

  for(let i=0;i<COLS;i++){
    const tile = grid[curRow][i];
    ((tile, cls, ch, idx)=>{
      setTimeout(()=>{
        tile.classList.add('pop');
        tile.classList.add(cls);

        const prev = keyStates[ch] || '';
        if(prev === 'correct'){
        } else if(prev === 'present'){
          if(cls === 'correct') keyStates[ch] = 'correct';
        } else {
          keyStates[ch] = cls;
        }
        updateKeyboardUI();
      }, idx*240);
      setTimeout(()=> tile.classList.remove('pop'), idx*240 + 420);
    })(tile, state[i], guess[i], i);
  }
  return state;
}

function updateKeyboardUI(){
  const keys = keyboardEl.querySelectorAll('.key');
  keys.forEach(k=>{
    const ch = (k.dataset.key || '').toLowerCase();
    k.classList.remove('absent','present','correct');
    if(ch && keyStates[ch]) k.classList.add(keyStates[ch]);
  });
}

function showMessage(msg, timeout=2200){
  statusEl.textContent = msg;
  if(timeout>0) setTimeout(()=>{ if(statusEl.textContent===msg) statusEl.textContent = ""; }, timeout);
}

// Timer functions
function startTimer(){
  if(startTime !== null) return; // already started
  startTime = Date.now();
  updateTimerDisplay();
  timerInterval = setInterval(updateTimerDisplay, 1000);
}

function stopTimer(){
  if(timerInterval){
    clearInterval(timerInterval);
    timerInterval = null;
  }
}

function resetTimer(){
  stopTimer();
  startTime = null;
  timerEl.textContent = "00:00";
}

function updateTimerDisplay(){
  if(startTime === null) {
    timerEl.textContent = "00:00";
    return;
  }
  const diff = Date.now() - startTime;
  const totalSeconds = Math.floor(diff/1000);
  const mins = Math.floor(totalSeconds/60);
  const secs = totalSeconds % 60;
  timerEl.textContent = `${mins.toString().padStart(2,'0')}:${secs.toString().padStart(2,'0')}`;
}

// Handle keys, with timer start on first letter typed
function handleKey(key){
  if(finished) return;
  if(key === 'Enter'){
    if(curCol < COLS){ showMessage("Not enough letters"); return; }
    const guess = getGuess();
    if(!VALID.has(guess)){ showMessage("Not in word list"); return; }
    const result = revealGuess(guess);
    setTimeout(()=>{
      if(result.every(r=>r==='correct')){
        finished=true;
        stopTimer();
        updateStats(true);
        statusEl.textContent = `You win! The word was "${solution.toUpperCase()}". Time: ${timerEl.textContent}`;
        updateStatsDisplay();
      } else {
        curRow++; curCol=0;
        if(curRow>=ROWS){
          finished=true;
          stopTimer();
          updateStats(false);
          statusEl.textContent = `Out of tries — the word was "${solution.toUpperCase()}".`;
          updateStatsDisplay();
        }
      }
    }, COLS*240 + 140);
  } else if(key === 'Backspace' || key === 'Back'){
    popLetter();
  } else {
    const letter = (key||'').toLowerCase();
    if(letter.length===1 && letter>='a' && letter<='z'){
      putLetter(letter);
      if(startTime === null) startTimer();
    }
  }
}

// Update stats after a finished game
function updateStats(won){
  stats.gamesPlayed++;
  if(won){
    stats.gamesWon++;
    const solveTimeSec = (Date.now() - startTime)/1000;
    stats.lastSolveTime = solveTimeSec;
    stats.solveTimes.push(solveTimeSec);
    if(stats.bestSolveTime === null || solveTimeSec < stats.bestSolveTime){
      stats.bestSolveTime = solveTimeSec;
    }
    // Increment guess distribution count (row number +1)
    stats.guessDist[curRow]++;
  } else {
    stats.gamesLost++;
  }

  // Update favorite word count
  let guess = getGuess();
  if(stats.guessesMade[guess]){
    stats.guessesMade[guess]++;
  } else {
    stats.guessesMade[guess] = 1;
  }

  saveStats();
}

function saveStats(){
  try {
    localStorage.setItem("leon_wordle_stats", JSON.stringify(stats));
  } catch(e) {
    console.warn("Failed to save stats:", e);
  }
}

function loadStats(){
  try {
    const data = localStorage.getItem("leon_wordle_stats");
    if(data){
      stats = JSON.parse(data);
      if(!stats.guessDist || stats.guessDist.length !== ROWS){
        stats.guessDist = [0,0,0,0,0,0];
      }
      if(!stats.guessesMade){
        stats.guessesMade = {};
      }
      if(!stats.solveTimes){
        stats.solveTimes = [];
      }
    }
  } catch(e) {
    console.warn("Failed to load stats:", e);
  }
}

function formatTime(seconds){
  if(seconds === null || seconds === undefined) return "-";
  const mins = Math.floor(seconds/60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${secs.toString().padStart(2,'0')}`;
}

function updateStatsDisplay(){
  statPlayedEl.textContent = stats.gamesPlayed;
  statWinsEl.textContent = stats.gamesWon;
  statLossesEl.textContent = stats.gamesLost;

  let winPercent = stats.gamesPlayed > 0 ? Math.round((stats.gamesWon / stats.gamesPlayed)*100) : 0;
  let lossPercent = stats.gamesPlayed > 0 ? 100 - winPercent : 0;

  statWinPercentEl.textContent = `${winPercent}%`;
  statLossPercentEl.textContent = `${lossPercent}%`;

  statLastTime.textContent = formatTime(stats.lastSolveTime);
  statBestTime.textContent = formatTime(stats.bestSolveTime);

  // Average time calc
  if(stats.solveTimes.length > 0){
    let avg = stats.solveTimes.reduce((a,b)=>a+b,0)/stats.solveTimes.length;
    statAvgTime.textContent = formatTime(avg);
  } else {
    statAvgTime.textContent = "-";
  }

  // Update guess distribution bars
  distBarsEl.innerHTML = "";
  const maxCount = Math.max(...stats.guessDist,1);
  stats.guessDist.forEach((count, i)=>{
    const percent = Math.round((count/maxCount)*100);
    const row = document.createElement('div');
    row.className = 'dist-bar-row';
    const label = document.createElement('div');
    label.className = 'dist-label';
    label.textContent = i+1;
    const bar = document.createElement('div');
    bar.className = 'dist-bar';
    const fill = document.createElement('div');
    fill.className = 'dist-bar-fill';
    fill.style.width = percent + '%';
    fill.textContent = count;
    bar.appendChild(fill);
    row.appendChild(label);
    row.appendChild(bar);
    distBarsEl.appendChild(row);
  });

  // Find favorite word (most entered)
  let fav = "-";
  let maxCountFav = 0;
  for(const w in stats.guessesMade){
    if(stats.guessesMade[w] > maxCountFav){
      maxCountFav = stats.guessesMade[w];
      fav = w.toUpperCase();
    }
  }
  favWordEl.textContent = `Favorite Word: ${fav}`;
}

function makeShareText(){
  let rowsText = [];
  const tiles = boardEl.querySelectorAll('.tile');
  for(let r=0;r<ROWS;r++){
    let rowState = ""; let rowHasAny=false;
    for(let c=0;c<COLS;c++){
      const t = tiles[r*COLS + c]; const ch = (t.textContent||"").trim();
      if(!ch){ rowState += '⬜'; continue; }
      rowHasAny = true;
      if(t.classList.contains('correct')) rowState += '🟩';
      else if(t.classList.contains('present')) rowState += '🟨';
      else if(t.classList.contains('absent')) rowState += '⬛';
      else rowState += '⬜';
    }
    if(rowHasAny) rowsText.push(rowState);
  }
  const title = `Leon’s Wordle — ${finished ? (statusEl.textContent.startsWith('You win') ? 'Solved' : 'Failed') : 'Play'}`;
  return `${title}\n${rowsText.join('\n')}\n(Guess the word!)`;
}

shareBtn.onclick = async ()=>{
  try{
    await navigator.clipboard.writeText(makeShareText());
    showMessage("Result copied to clipboard!");
  }catch(e){
    showMessage("Copy failed — try manually.");
  }
};

customBtn.onclick = ()=>{
  const input = prompt("Enter your custom 5-letter word (any letters):").toLowerCase().trim();
  if(input.length !== 5){
    alert("Word must be exactly 5 letters.");
    return;
  }
  if(!/^[a-z]{5}$/.test(input)){
    alert("Word must only contain letters a-z.");
    return;
  }
  const encoded = btoa(input); // encode in base64
  const url = `${window.location.origin}${window.location.pathname}#custom=${encoded}`;
  prompt("Share this link with others to play your custom Wordle:", url);
};

statsBtn.onclick = ()=>{
  updateStatsDisplay();
  statsModal.classList.add('active');
  statsModal.focus();
};

closeStatsBtn.onclick = ()=>{
  statsModal.classList.remove('active');
};

window.addEventListener('keydown', (e)=>{
  if(statsModal.classList.contains('active')){
    if(e.key === 'Escape'){
      statsModal.classList.remove('active');
      return;
    }
    // block keypresses while modal open
    e.preventDefault();
    return;
  }

  if(e.key === 'Enter' || e.key === 'Backspace'){
    handleKey(e.key);
    e.preventDefault();
    return;
  }
  const k = e.key.toLowerCase();
  if(k.length===1 && k>='a' && k<='z') handleKey(k);
});

(async ()=>{
  loadStats();
  buildBoard();
  buildKeyboard();
  await loadLists();
  startNewGame();  // This picks the solution, decoding custom word if any
})();

newBtn.onclick = startNewGame;

</script>
</body>
</html>
