<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Leon’s Wordle</title>
  <style>
    :root{
      --bg:#0b1220; --tile:#111827; --text:#e6eef8; --muted:#9aa7bf;
      --green:#6aaa64; --yellow:#c9b458; --gray:#3a3a3c; --accent:#2563eb;
      --tile-size:64px;
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    }
    *{box-sizing:border-box}
    body{margin:0; background:linear-gradient(180deg,#071020,#0b1220); color:var(--text);
      display:flex; align-items:center; justify-content:center; min-height:100vh; padding:20px;}
    .app{ width: min(760px, 96vw); text-align:center; }
    h1{margin:0 0 6px 0; font-size:22px}
    p.lead{color:var(--muted); margin:4px 0 12px 0}
    .board{display:grid; grid-template-rows: repeat(6, var(--tile-size)); gap:8px; justify-content:center; margin:18px 0;}
    .row{ display:grid; grid-template-columns: repeat(5, var(--tile-size)); gap:8px; }
    .tile{ width:var(--tile-size); height:var(--tile-size); background:var(--tile);
      display:flex; align-items:center; justify-content:center; font-weight:700; font-size:28px;
      border-radius:8px; user-select:none; color:var(--text); text-transform:uppercase;
      transition: transform .08s ease, background .2s ease; }
    .tile.pop{ transform: scale(1.08); }
    .tile.filled{ border:2px solid #2b3440; }
    .tile.absent{ background:var(--gray); color:white; }
    .tile.present{ background:var(--yellow); color:white; }
    .tile.correct{ background:var(--green); color:white; }
    .keyboard{ margin-top:10px; display:flex; flex-direction:column; gap:8px; align-items:center; user-select:none; }
    .kb-row{ display:flex; gap:6px; }
    .key{ padding:10px 12px; min-width:42px; border-radius:6px; background:#0f1724; color:var(--text);
      font-weight:700; cursor:pointer; text-transform:uppercase; transition: background .3s ease; }
    .key.wide{ min-width:72px; }
    .key.absent{ background: var(--gray); color: white; }
    .key.present{ background: var(--yellow); color: white; }
    .key.correct{ background: var(--green); color: white; }
    .status{ margin-top:14px; min-height:28px; color:var(--muted); font-weight:700; }
    .controls{ margin-top:12px; display:flex; gap:8px; justify-content:center; flex-wrap:wrap; }
    button.btn{ background:var(--accent); color:white; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:700; }
    .small{ font-size:13px; color:var(--muted); margin-top:6px;}
    @media (max-width:520px){ :root{ --tile-size:48px } .key{ padding:8px 10px } .controls{justify-content:center} }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Leon’s Wordle">
    <h1>Leon’s Wordle</h1>
    <p class="lead">Use the "Custom Word" button to create a shareable link for any 5-letter word!</p>

    <div id="board" class="board" aria-live="polite"></div>
    <div id="status" class="status" aria-atomic="true">Loading word lists...</div>
    <div id="keyboard" class="keyboard"></div>

    <div class="controls">
      <button id="newBtn" class="btn">New Game</button>
      <button id="shareBtn" class="btn" title="Copy result to clipboard">Share</button>
      <button id="customBtn" class="btn" title="Create a custom Wordle link">Custom Word</button>
    </div>
    <p class="small">If fetching the full lists fails (offline), the game will still run with a small fallback list.</p>
  </div>

<script>
const ROWS = 6, COLS = 5;
const boardEl = document.getElementById('board');
const keyboardEl = document.getElementById('keyboard');
const statusEl = document.getElementById('status');
const newBtn = document.getElementById('newBtn');
const shareBtn = document.getElementById('shareBtn');
const customBtn = document.getElementById('customBtn');

let grid = [];
let curRow = 0, curCol = 0;
let solution = "";
let finished = false;
let keyStates = {};
let SOLUTIONS = [];
let VALID = new Set();

const FALLBACK_SOLUTIONS = ["apple","baker","cigar","delta","eagle","flame","grace","hotel","image","jelly"];
const FALLBACK_VALID = new Set([...FALLBACK_SOLUTIONS, "about","other","which","their","there","could","would","these","think","place","under","right","first","still"]);

const GIST_ANSWERS_RAW = "https://gist.githubusercontent.com/cfreshman/a03ef2cba789d8cf00c08f767e0fad7b/raw/wordle-answers-alphabetical.txt";
const GIST_ALLOWED_RAW  = "https://gist.githubusercontent.com/cfreshman/cdcdf777450c5b5301e439061d29694c/raw/wordle-allowed-guesses.txt";

function buildBoard(){
  boardEl.innerHTML = "";
  grid = [];
  for(let r=0;r<ROWS;r++){
    const row = document.createElement('div'); row.className='row';
    let rowArr = [];
    for(let c=0;c<COLS;c++){
      const tile = document.createElement('div'); tile.className='tile';
      tile.dataset.row=r; tile.dataset.col=c; tile.setAttribute('role','gridcell');
      row.appendChild(tile); rowArr.push(tile);
    }
    boardEl.appendChild(row); grid.push(rowArr);
  }
}

const KEYBOARD_ROWS = ["qwertyuiop","asdfghjkl","zxcvbnm"];
function buildKeyboard(){
  keyboardEl.innerHTML = "";
  KEYBOARD_ROWS.forEach((row, idx)=>{
    const r = document.createElement('div'); r.className='kb-row';
    if(idx===2){
      const enter = document.createElement('div'); enter.className='key wide'; enter.textContent='Enter';
      enter.dataset.key='Enter'; enter.onclick = ()=>handleKey('Enter'); r.appendChild(enter);
    }
    for(const ch of row){
      const key = document.createElement('div'); key.className='key'; key.textContent=ch; key.dataset.key=ch;
      key.onclick = ()=>handleKey(ch); r.appendChild(key);
    }
    if(idx===2){
      const bk = document.createElement('div'); bk.className='key wide'; bk.textContent='Back'; bk.dataset.key='Backspace';
      bk.onclick = ()=>handleKey('Backspace'); r.appendChild(bk);
    }
    keyboardEl.appendChild(r);
  });
}

async function loadLists(){
  statusEl.textContent = "Fetching Wordle lists...";
  try{
    const [ansResp, allowedResp] = await Promise.all([
      fetch(GIST_ANSWERS_RAW),
      fetch(GIST_ALLOWED_RAW)
    ]);

    if(!ansResp.ok || !allowedResp.ok) throw new Error("Fetch failed");

    const [ansText, allowedText] = await Promise.all([ansResp.text(), allowedResp.text()]);

    SOLUTIONS = ansText.split(/\r?\n/).map(s=>s.trim().toLowerCase()).filter(s=>s.length===5);
    const allowed = allowedText.split(/\r?\n/).map(s=>s.trim().toLowerCase()).filter(s=>s.length===5);

    VALID = new Set(allowed);
    SOLUTIONS.forEach(w=>VALID.add(w));

    statusEl.textContent = `Loaded ${SOLUTIONS.length} solutions and ${VALID.size} allowed guesses.`;
    console.log("Loaded lists: solutions:", SOLUTIONS.length, "allowed:", VALID.size);
  }catch(err){
    console.warn("Failed to fetch lists, using fallback. Error:", err);
    statusEl.textContent = "Offline or blocked — using fallback small word list.";
    SOLUTIONS = FALLBACK_SOLUTIONS.slice();
    VALID = new Set(FALLBACK_VALID);
  }
}

function getCustomWordFromHash(){
  const hash = window.location.hash.slice(1);
  if(!hash.startsWith("custom=")) return null;
  const code = hash.slice(7);
  try {
    const word = atob(code).toLowerCase();
    if(word.length !== 5) return null;
    if(!/^[a-z]{5}$/.test(word)) return null; // Only letters allowed
    return word;
  } catch(e) {
    return null;
  }
}

function pickSolution(){
  const custom = getCustomWordFromHash();
  if(custom){
    solution = custom;
    if(!VALID.has(solution)){
      VALID.add(solution);  // Add custom word to VALID guesses so you can guess it!
      statusEl.textContent = `Playing custom word: ${solution.toUpperCase()} (not in dictionary)`;
    } else {
      statusEl.textContent = `Playing custom word: ${solution.toUpperCase()}`;
    }
  } else {
    solution = SOLUTIONS[Math.floor(Math.random()*SOLUTIONS.length)];
    statusEl.textContent = "Good luck — guess the 5-letter word!";
  }
  console.log("solution:", solution);
}

function startNewGame(){
  buildBoard();
  buildKeyboard();
  curRow = 0; curCol = 0; finished = false; keyStates = {};
  updateKeyboardUI();
  pickSolution();
}

function putLetter(ch){
  if(finished) return;
  if(curCol >= COLS) return;
  grid[curRow][curCol].textContent = ch.toUpperCase();
  grid[curRow][curCol].classList.add('filled');
  curCol++;
}

function popLetter(){
  if(finished) return;
  if(curCol <= 0) return;
  curCol--;
  grid[curRow][curCol].textContent = "";
  grid[curRow][curCol].classList.remove('filled');
}

function getGuess(){
  let s="";
  for(let c=0;c<COLS;c++) s += (grid[curRow][c].textContent || "").toLowerCase();
  return s;
}

function revealGuess(guess){
  const solArr = solution.split('');
  const state = Array(COLS).fill('absent');

  for(let i=0;i<COLS;i++){
    if(guess[i] === solArr[i]){
      state[i] = 'correct';
      solArr[i] = null;
    }
  }

  const counts = {};
  for(const ch of solArr){
    if(!ch) continue;
    counts[ch] = (counts[ch]||0)+1;
  }

  for(let i=0;i<COLS;i++){
    if(state[i] === 'correct') continue;
    const g = guess[i];
    if(counts[g] > 0){
      state[i] = 'present';
      counts[g]--;
    } else {
      state[i] = 'absent';
    }
  }

  for(let i=0;i<COLS;i++){
    const tile = grid[curRow][i];
    ((tile, cls, ch, idx)=>{
      setTimeout(()=>{
        tile.classList.add('pop');
        tile.classList.add(cls);

        const prev = keyStates[ch] || '';
        if(prev === 'correct'){
        } else if(prev === 'present'){
          if(cls === 'correct') keyStates[ch] = 'correct';
        } else {
          keyStates[ch] = cls;
        }
        updateKeyboardUI();
      }, idx*240);
      setTimeout(()=> tile.classList.remove('pop'), idx*240 + 420);
    })(tile, state[i], guess[i], i);
  }
  return state;
}

function updateKeyboardUI(){
  const keys = keyboardEl.querySelectorAll('.key');
  keys.forEach(k=>{
    const ch = (k.dataset.key || '').toLowerCase();
    k.classList.remove('absent','present','correct');
    if(ch && keyStates[ch]) k.classList.add(keyStates[ch]);
  });
}

function showMessage(msg, timeout=2200){
  statusEl.textContent = msg;
  if(timeout>0) setTimeout(()=>{ if(statusEl.textContent===msg) statusEl.textContent = ""; }, timeout);
}

function handleKey(key){
  if(finished) return;
  if(key === 'Enter'){
    if(curCol < COLS){ showMessage("Not enough letters"); return; }
    const guess = getGuess();
    if(!VALID.has(guess)){ showMessage("Not in word list"); return; }
    const result = revealGuess(guess);
    setTimeout(()=>{
      if(result.every(r=>r==='correct')){
        finished=true;
        statusEl.textContent = `You win! The word was "${solution.toUpperCase()}".`;
      } else {
        curRow++; curCol=0;
        if(curRow>=ROWS){
          finished=true;
          statusEl.textContent = `Out of tries — the word was "${solution.toUpperCase()}".`;
        }
      }
    }, COLS*240 + 140);
  } else if(key === 'Backspace' || key === 'Back'){
    popLetter();
  } else {
    const letter = (key||'').toLowerCase();
    if(letter.length===1 && letter>='a' && letter<='z') putLetter(letter);
  }
}

function makeShareText(){
  let rowsText = [];
  const tiles = boardEl.querySelectorAll('.tile');
  for(let r=0;r<ROWS;r++){
    let rowState = ""; let rowHasAny=false;
    for(let c=0;c<COLS;c++){
      const t = tiles[r*COLS + c]; const ch = (t.textContent||"").trim();
      if(!ch){ rowState += '⬜'; continue; }
      rowHasAny = true;
      if(t.classList.contains('correct')) rowState += '🟩';
      else if(t.classList.contains('present')) rowState += '🟨';
      else if(t.classList.contains('absent')) rowState += '⬛';
      else rowState += '⬜';
    }
    if(rowHasAny) rowsText.push(rowState);
  }
  const title = `Leon’s Wordle — ${finished ? (statusEl.textContent.startsWith('You win') ? 'Solved' : 'Failed') : 'Play'}`;
  return `${title}\n${rowsText.join('\n')}\n(Guess the word!)`;
}

shareBtn.onclick = async ()=>{
  try{
    await navigator.clipboard.writeText(makeShareText());
    showMessage("Result copied to clipboard!");
  }catch(e){
    showMessage("Copy failed — try manually.");
  }
};

customBtn.onclick = ()=>{
  const input = prompt("Enter your custom 5-letter word (any letters):").toLowerCase().trim();
  if(input.length !== 5){
    alert("Word must be exactly 5 letters.");
    return;
  }
  if(!/^[a-z]{5}$/.test(input)){
    alert("Word must only contain letters a-z.");
    return;
  }
  const encoded = btoa(input); // encode in base64
  const url = `${window.location.origin}${window.location.pathname}#custom=${encoded}`;
  prompt("Share this link with others to play your custom Wordle:", url);
};

window.addEventListener('keydown', (e)=>{
  if(e.key === 'Enter' || e.key === 'Backspace'){
    handleKey(e.key);
    e.preventDefault();
    return;
  }
  const k = e.key.toLowerCase();
  if(k.length===1 && k>='a' && k<='z') handleKey(k);
});

(async ()=>{
  buildBoard();
  buildKeyboard();
  await loadLists();
  startNewGame();  // This picks the solution, decoding custom word if any
})();

newBtn.onclick = startNewGame;

</script>
</body>
</html>
